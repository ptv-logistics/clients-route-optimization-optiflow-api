/* tslint:disable */
/* eslint-disable */
/**
 * Route Optimization OptiFlow
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.42
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * Describes a constraint where tasks are forbidden to be loaded or unloaded depending on other orders which are loaded in the vehicle or in a compartment of a vehicle. If a vehicle has compartments specified, the constraint is applied individually to each compartment. If no compartments are specified, the constraint applies to the vehicle as a whole.
 * @export
 * @interface RouteOptimizationTaskLoadingIncompatibilityConstraint
 */
export interface RouteOptimizationTaskLoadingIncompatibilityConstraint {
    /**
     * Orders belonging to this category must be loaded in the vehicle or in a compartment of the vehicle for this constraint to apply. The constraint will be ignored when no order belongs to this category.
     * @type {string}
     * @memberof RouteOptimizationTaskLoadingIncompatibilityConstraint
     */
    loadedOrderCategory: string;
    /**
     * Tasks belonging to this category cannot be loaded or unloaded while the constraint applies. The constraint will be ignored when no task belongs to this category.
     * @type {string}
     * @memberof RouteOptimizationTaskLoadingIncompatibilityConstraint
     */
    forbiddenTaskCategory: string;
    /**
     * The category of vehicles to which this constraint applies. If a vehicle has compartments, the constraint applies to each compartment individually within vehicles of this category. When omitted the constraint applies to all vehicles. The constraint will be ignored when no vehicle belongs to this category.
     * @type {string}
     * @memberof RouteOptimizationTaskLoadingIncompatibilityConstraint
     */
    vehicleCategory?: string;
}

/**
 * Check if a given object implements the RouteOptimizationTaskLoadingIncompatibilityConstraint interface.
 */
export function instanceOfRouteOptimizationTaskLoadingIncompatibilityConstraint(value: object): boolean {
    if (!('loadedOrderCategory' in value)) return false;
    if (!('forbiddenTaskCategory' in value)) return false;
    return true;
}

export function RouteOptimizationTaskLoadingIncompatibilityConstraintFromJSON(json: any): RouteOptimizationTaskLoadingIncompatibilityConstraint {
    return RouteOptimizationTaskLoadingIncompatibilityConstraintFromJSONTyped(json, false);
}

export function RouteOptimizationTaskLoadingIncompatibilityConstraintFromJSONTyped(json: any, ignoreDiscriminator: boolean): RouteOptimizationTaskLoadingIncompatibilityConstraint {
    if (json == null) {
        return json;
    }
    return {
        
        'loadedOrderCategory': json['loadedOrderCategory'],
        'forbiddenTaskCategory': json['forbiddenTaskCategory'],
        'vehicleCategory': json['vehicleCategory'] == null ? undefined : json['vehicleCategory'],
    };
}

export function RouteOptimizationTaskLoadingIncompatibilityConstraintToJSON(value?: RouteOptimizationTaskLoadingIncompatibilityConstraint | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'loadedOrderCategory': value['loadedOrderCategory'],
        'forbiddenTaskCategory': value['forbiddenTaskCategory'],
        'vehicleCategory': value['vehicleCategory'],
    };
}

