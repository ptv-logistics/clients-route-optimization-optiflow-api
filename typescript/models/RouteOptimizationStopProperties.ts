/* tslint:disable */
/* eslint-disable */
/**
 * Route Optimization OptiFlow
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.23
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { RouteOptimizationStopConcurrency } from './RouteOptimizationStopConcurrency';
import {
    RouteOptimizationStopConcurrencyFromJSON,
    RouteOptimizationStopConcurrencyFromJSONTyped,
    RouteOptimizationStopConcurrencyToJSON,
} from './RouteOptimizationStopConcurrency';
import type { RouteOptimizationTimeSlot } from './RouteOptimizationTimeSlot';
import {
    RouteOptimizationTimeSlotFromJSON,
    RouteOptimizationTimeSlotFromJSONTyped,
    RouteOptimizationTimeSlotToJSON,
} from './RouteOptimizationTimeSlot';

/**
 * Specifies the necessary information needed to schedule a stop at this location. This information is not relevant when the location is the start or end location of a vehicle.
 * @export
 * @interface RouteOptimizationStopProperties
 */
export interface RouteOptimizationStopProperties {
    /**
     * Defines a duration [s] that is needed before an appointment (one or more tasks) can start at this location. This duration is needed once per stop whenever tasks are executed.
     * @type {number}
     * @memberof RouteOptimizationStopProperties
     */
    preparationDuration?: number;
    /**
     * A list of time intervals that describe when tasks can be executed at this location. Consecutive tasks with the same time slot are grouped to an appointment. The timings of the appointment must satisfy the restrictions of the time slot. When omitted or empty, all tasks within a stop at this location will be grouped into one appointment and the timings of this appointment are unrestricted.
     * @type {Array<RouteOptimizationTimeSlot>}
     * @memberof RouteOptimizationStopProperties
     */
    timeSlots?: Array<RouteOptimizationTimeSlot>;
    /**
     * 
     * @type {RouteOptimizationStopConcurrency}
     * @memberof RouteOptimizationStopProperties
     */
    concurrency?: RouteOptimizationStopConcurrency;
}

/**
 * Check if a given object implements the RouteOptimizationStopProperties interface.
 */
export function instanceOfRouteOptimizationStopProperties(value: object): boolean {
    return true;
}

export function RouteOptimizationStopPropertiesFromJSON(json: any): RouteOptimizationStopProperties {
    return RouteOptimizationStopPropertiesFromJSONTyped(json, false);
}

export function RouteOptimizationStopPropertiesFromJSONTyped(json: any, ignoreDiscriminator: boolean): RouteOptimizationStopProperties {
    if (json == null) {
        return json;
    }
    return {
        
        'preparationDuration': json['preparationDuration'] == null ? undefined : json['preparationDuration'],
        'timeSlots': json['timeSlots'] == null ? undefined : ((json['timeSlots'] as Array<any>).map(RouteOptimizationTimeSlotFromJSON)),
        'concurrency': json['concurrency'] == null ? undefined : RouteOptimizationStopConcurrencyFromJSON(json['concurrency']),
    };
}

export function RouteOptimizationStopPropertiesToJSON(value?: RouteOptimizationStopProperties | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'preparationDuration': value['preparationDuration'],
        'timeSlots': value['timeSlots'] == null ? undefined : ((value['timeSlots'] as Array<any>).map(RouteOptimizationTimeSlotToJSON)),
        'concurrency': RouteOptimizationStopConcurrencyToJSON(value['concurrency']),
    };
}

