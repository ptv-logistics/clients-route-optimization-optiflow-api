/* tslint:disable */
/* eslint-disable */
/**
 * Route Optimization OptiFlow
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.48
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RouteOptimizationErrorResponse,
  RouteOptimizationOptimizationIdentifier,
  RouteOptimizationOptimizationProgress,
  RouteOptimizationOptimizationRequest,
  RouteOptimizationOptimizationResult,
  RouteOptimizationOptimizationStatus,
  RouteOptimizationOptimizationSummaries,
  RouteOptimizationUpdateMetadataRequest,
} from '../models/index';
import {
    RouteOptimizationErrorResponseFromJSON,
    RouteOptimizationErrorResponseToJSON,
    RouteOptimizationOptimizationIdentifierFromJSON,
    RouteOptimizationOptimizationIdentifierToJSON,
    RouteOptimizationOptimizationProgressFromJSON,
    RouteOptimizationOptimizationProgressToJSON,
    RouteOptimizationOptimizationRequestFromJSON,
    RouteOptimizationOptimizationRequestToJSON,
    RouteOptimizationOptimizationResultFromJSON,
    RouteOptimizationOptimizationResultToJSON,
    RouteOptimizationOptimizationStatusFromJSON,
    RouteOptimizationOptimizationStatusToJSON,
    RouteOptimizationOptimizationSummariesFromJSON,
    RouteOptimizationOptimizationSummariesToJSON,
    RouteOptimizationUpdateMetadataRequestFromJSON,
    RouteOptimizationUpdateMetadataRequestToJSON,
} from '../models/index';

export interface DeleteOptimizationRequest {
    id: string;
}

export interface GetOptimizationProgressRequest {
    id: string;
}

export interface GetOptimizationRequestRequest {
    id: string;
}

export interface GetOptimizationResultRequest {
    id: string;
}

export interface ListOptimizationsRequest {
    cursor?: string;
    limit?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    name?: string;
    tags?: Array<string>;
    statuses?: Array<RouteOptimizationOptimizationStatus>;
}

export interface StartOptimizationRequest {
    routeOptimizationOptimizationRequest: RouteOptimizationOptimizationRequest;
}

export interface StopOptimizationRequest {
    id: string;
}

export interface UpdateOptimizationMetadataRequest {
    id: string;
    routeOptimizationUpdateMetadataRequest: RouteOptimizationUpdateMetadataRequest;
}

/**
 * 
 */
export class OptimizationApi extends runtime.BaseAPI {

    /**
     * Deletes the optimization. Also stops the optimization if it is currently running. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async deleteOptimizationRaw(requestParameters: DeleteOptimizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteOptimization().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the optimization. Also stops the optimization if it is currently running. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async deleteOptimization(requestParameters: DeleteOptimizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteOptimizationRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the optimization progress. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getOptimizationProgressRaw(requestParameters: GetOptimizationProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteOptimizationOptimizationProgress>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getOptimizationProgress().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations/{id}/progress`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteOptimizationOptimizationProgressFromJSON(jsonValue));
    }

    /**
     * Retrieves the optimization progress. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getOptimizationProgress(requestParameters: GetOptimizationProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteOptimizationOptimizationProgress> {
        const response = await this.getOptimizationProgressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the original request for the optimization. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getOptimizationRequestRaw(requestParameters: GetOptimizationRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteOptimizationOptimizationRequest>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getOptimizationRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations/{id}/request`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteOptimizationOptimizationRequestFromJSON(jsonValue));
    }

    /**
     * Retrieves the original request for the optimization. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getOptimizationRequest(requestParameters: GetOptimizationRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteOptimizationOptimizationRequest> {
        const response = await this.getOptimizationRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the current result of the optimization. While the optimization is running, this will return intermediate metrics to track the progress. Once succeeded, the optimized routes are returned. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getOptimizationResultRaw(requestParameters: GetOptimizationResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteOptimizationOptimizationResult>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getOptimizationResult().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteOptimizationOptimizationResultFromJSON(jsonValue));
    }

    /**
     * Retrieves the current result of the optimization. While the optimization is running, this will return intermediate metrics to track the progress. Once succeeded, the optimized routes are returned. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getOptimizationResult(requestParameters: GetOptimizationResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteOptimizationOptimizationResult> {
        const response = await this.getOptimizationResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of optimization summaries that match the specified search criteria. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async listOptimizationsRaw(requestParameters: ListOptimizationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteOptimizationOptimizationSummaries>> {
        const queryParameters: any = {};

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['statuses'] != null) {
            queryParameters['statuses'] = requestParameters['statuses'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteOptimizationOptimizationSummariesFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of optimization summaries that match the specified search criteria. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async listOptimizations(requestParameters: ListOptimizationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteOptimizationOptimizationSummaries> {
        const response = await this.listOptimizationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Initiates a cost-minimizing optimization that efficiently schedules orders onto routes. The routes are assigned to the provided vehicles and satisfy the given constraints. Once the optimization is accepted, the optimization starts for the requested duration after which the resulting routes can be retrieved. Zstd or Gzip-encoded content is supported in the request body and returned in the response if accepted by the client.
     */
    async startOptimizationRaw(requestParameters: StartOptimizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteOptimizationOptimizationIdentifier>> {
        if (requestParameters['routeOptimizationOptimizationRequest'] == null) {
            throw new runtime.RequiredError(
                'routeOptimizationOptimizationRequest',
                'Required parameter "routeOptimizationOptimizationRequest" was null or undefined when calling startOptimization().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RouteOptimizationOptimizationRequestToJSON(requestParameters['routeOptimizationOptimizationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteOptimizationOptimizationIdentifierFromJSON(jsonValue));
    }

    /**
     * Initiates a cost-minimizing optimization that efficiently schedules orders onto routes. The routes are assigned to the provided vehicles and satisfy the given constraints. Once the optimization is accepted, the optimization starts for the requested duration after which the resulting routes can be retrieved. Zstd or Gzip-encoded content is supported in the request body and returned in the response if accepted by the client.
     */
    async startOptimization(requestParameters: StartOptimizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteOptimizationOptimizationIdentifier> {
        const response = await this.startOptimizationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops an optimization. Once accepted, the optimization will stop as soon as possible and the final state of the routes can be retrieved. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async stopOptimizationRaw(requestParameters: StopOptimizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling stopOptimization().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations/{id}/stop`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stops an optimization. Once accepted, the optimization will stop as soon as possible and the final state of the routes can be retrieved. Zstd or Gzip-encoded content is returned in the response if accepted by the client.
     */
    async stopOptimization(requestParameters: StopOptimizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stopOptimizationRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the metadata of an optimization.
     */
    async updateOptimizationMetadataRaw(requestParameters: UpdateOptimizationMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateOptimizationMetadata().'
            );
        }

        if (requestParameters['routeOptimizationUpdateMetadataRequest'] == null) {
            throw new runtime.RequiredError(
                'routeOptimizationUpdateMetadataRequest',
                'Required parameter "routeOptimizationUpdateMetadataRequest" was null or undefined when calling updateOptimizationMetadata().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/optimizations/{id}/metadata`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RouteOptimizationUpdateMetadataRequestToJSON(requestParameters['routeOptimizationUpdateMetadataRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the metadata of an optimization.
     */
    async updateOptimizationMetadata(requestParameters: UpdateOptimizationMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateOptimizationMetadataRaw(requestParameters, initOverrides);
    }

}
