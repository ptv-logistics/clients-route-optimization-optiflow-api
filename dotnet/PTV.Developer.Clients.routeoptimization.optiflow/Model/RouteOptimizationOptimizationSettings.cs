/*
 * Route Optimization OptiFlow
 *
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.42
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.optiflow.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.optiflow.Model
{
    /// <summary>
    /// General settings of the optimization.
    /// </summary>
    [DataContract(Name = "OptimizationSettings")]
    public partial class RouteOptimizationOptimizationSettings : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteOptimizationOptimizationSettings" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RouteOptimizationOptimizationSettings() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteOptimizationOptimizationSettings" /> class.
        /// </summary>
        /// <param name="duration">Defines the maximum duration [s] the optimization can use to reduce the cost of the scheduled routes. Please note that the upper bound on optimization duration is a technical limit. Check your individual price plan or contract to see which limits apply. The optimization will automatically stop when this duration is spent in the &#x60;RUNNING&#x60; status but can also be stopped manually using the *stopOptimization* endpoint. (required).</param>
        /// <param name="maximumStagnationDuration">Defines the maximum duration [s] the optimization may continue without improving the best-known solution. If no better solution is found within this period, the optimization will stop early - even if the overall duration limit has not yet been reached. This mechanism helps reduce unnecessary computation time when progress stalls. The stagnation timer starts when the optimization enters the &#x60;RUNNING&#x60; status and resets each time a better solution is found. *Use with caution:* This feature may prematurely terminate optimizations that could still yield better solutions given more time. Since the timing of improvements is inherently unpredictable, relying on this setting can lead to suboptimal results. It is recommended to disable this feature or set a conservative value unless you have strong reasons to limit runtime based on stagnation..</param>
        public RouteOptimizationOptimizationSettings(int? duration = default(int?), int? maximumStagnationDuration = default(int?))
        {
            // to ensure "duration" is required (not null)
            if (duration == null)
            {
                throw new ArgumentNullException("duration is a required property for RouteOptimizationOptimizationSettings and cannot be null");
            }
            this.Duration = duration;
            this.MaximumStagnationDuration = maximumStagnationDuration;
        }

        /// <summary>
        /// Defines the maximum duration [s] the optimization can use to reduce the cost of the scheduled routes. Please note that the upper bound on optimization duration is a technical limit. Check your individual price plan or contract to see which limits apply. The optimization will automatically stop when this duration is spent in the &#x60;RUNNING&#x60; status but can also be stopped manually using the *stopOptimization* endpoint.
        /// </summary>
        /// <value>Defines the maximum duration [s] the optimization can use to reduce the cost of the scheduled routes. Please note that the upper bound on optimization duration is a technical limit. Check your individual price plan or contract to see which limits apply. The optimization will automatically stop when this duration is spent in the &#x60;RUNNING&#x60; status but can also be stopped manually using the *stopOptimization* endpoint.</value>
        /// <example>7200</example>
        [DataMember(Name = "duration", IsRequired = true, EmitDefaultValue = true)]
        public int? Duration { get; set; }

        /// <summary>
        /// Defines the maximum duration [s] the optimization may continue without improving the best-known solution. If no better solution is found within this period, the optimization will stop early - even if the overall duration limit has not yet been reached. This mechanism helps reduce unnecessary computation time when progress stalls. The stagnation timer starts when the optimization enters the &#x60;RUNNING&#x60; status and resets each time a better solution is found. *Use with caution:* This feature may prematurely terminate optimizations that could still yield better solutions given more time. Since the timing of improvements is inherently unpredictable, relying on this setting can lead to suboptimal results. It is recommended to disable this feature or set a conservative value unless you have strong reasons to limit runtime based on stagnation.
        /// </summary>
        /// <value>Defines the maximum duration [s] the optimization may continue without improving the best-known solution. If no better solution is found within this period, the optimization will stop early - even if the overall duration limit has not yet been reached. This mechanism helps reduce unnecessary computation time when progress stalls. The stagnation timer starts when the optimization enters the &#x60;RUNNING&#x60; status and resets each time a better solution is found. *Use with caution:* This feature may prematurely terminate optimizations that could still yield better solutions given more time. Since the timing of improvements is inherently unpredictable, relying on this setting can lead to suboptimal results. It is recommended to disable this feature or set a conservative value unless you have strong reasons to limit runtime based on stagnation.</value>
        /// <example>1200</example>
        [DataMember(Name = "maximumStagnationDuration", EmitDefaultValue = true)]
        public int? MaximumStagnationDuration { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RouteOptimizationOptimizationSettings {\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  MaximumStagnationDuration: ").Append(MaximumStagnationDuration).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Duration (int?) maximum
            if (this.Duration > (int?)86400)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Duration, must be a value less than or equal to 86400.", new [] { "Duration" });
            }

            // Duration (int?) minimum
            if (this.Duration < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Duration, must be a value greater than or equal to 0.", new [] { "Duration" });
            }

            // MaximumStagnationDuration (int?) maximum
            if (this.MaximumStagnationDuration > (int?)86400)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaximumStagnationDuration, must be a value less than or equal to 86400.", new [] { "MaximumStagnationDuration" });
            }

            // MaximumStagnationDuration (int?) minimum
            if (this.MaximumStagnationDuration < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaximumStagnationDuration, must be a value greater than or equal to 1.", new [] { "MaximumStagnationDuration" });
            }

            yield break;
        }
    }

}
