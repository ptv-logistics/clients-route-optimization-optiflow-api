/*
 * Route Optimization OptiFlow
 *
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.42
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.optiflow.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.optiflow.Model
{
    /// <summary>
    /// A description of the route structure that can be used to reconstruct the route.
    /// </summary>
    [DataContract(Name = "RouteStructure")]
    public partial class RouteOptimizationRouteStructure : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteOptimizationRouteStructure" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RouteOptimizationRouteStructure() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteOptimizationRouteStructure" /> class.
        /// </summary>
        /// <param name="vehicleId">The unique identifier of the vehicle that is used to execute the route. Only a single route can be provided for each vehicle. (required).</param>
        /// <param name="resourceIds">The unique identifiers of the resources assigned to the vehicle executing the route..</param>
        /// <param name="start">The point in time when the route should start. The start time will be respected as closely as possible. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). The date must not be before &#x60;1970-01-01T00:00:00+00:00&#x60; nor after &#x60;2037-12-31T23:59:59+00:00&#x60;. The date must provide an offset to UTC. (required).</param>
        /// <param name="startLocationId">The unique identifier of the location where the route starts. This must either be the provided start location of the vehicle, the location of the first stop when the vehicle has no fixed start location or a layover location. When omitted, the location will be automatically inferred, assuming a layover does not occur before this route..</param>
        /// <param name="endLocationId">The unique identifier of the location where the route ends. This must either be the provided end location of the vehicle, the location of the last stop when the vehicle has no fixed end location or a layover location. When omitted, the location will be automatically inferred, assuming a layover does not occur after this route..</param>
        /// <param name="tasks">A sequence of tasks scheduled on the route..</param>
        /// <param name="breaks">A list of breaks scheduled on the route. When omitted, reconstruction will make a best effort to schedule breaks in order to satisfy the break settings..</param>
        /// <param name="charging">A list of charging times scheduled on the route. When omitted, reconstruction will make a best effort to schedule charging in order to satisfy the vehicle’s requirements..</param>
        public RouteOptimizationRouteStructure(string vehicleId = default(string), List<string> resourceIds = default(List<string>), DateTimeOffset? start = default(DateTimeOffset?), string startLocationId = default(string), string endLocationId = default(string), List<RouteOptimizationTaskStructure> tasks = default(List<RouteOptimizationTaskStructure>), List<RouteOptimizationBreakStructure> breaks = default(List<RouteOptimizationBreakStructure>), List<RouteOptimizationChargingStructure> charging = default(List<RouteOptimizationChargingStructure>))
        {
            // to ensure "vehicleId" is required (not null)
            if (vehicleId == null)
            {
                throw new ArgumentNullException("vehicleId is a required property for RouteOptimizationRouteStructure and cannot be null");
            }
            this.VehicleId = vehicleId;
            // to ensure "start" is required (not null)
            if (start == null)
            {
                throw new ArgumentNullException("start is a required property for RouteOptimizationRouteStructure and cannot be null");
            }
            this.Start = start;
            this.ResourceIds = resourceIds;
            this.StartLocationId = startLocationId;
            this.EndLocationId = endLocationId;
            this.Tasks = tasks;
            this.Breaks = breaks;
            this.Charging = charging;
        }

        /// <summary>
        /// The unique identifier of the vehicle that is used to execute the route. Only a single route can be provided for each vehicle.
        /// </summary>
        /// <value>The unique identifier of the vehicle that is used to execute the route. Only a single route can be provided for each vehicle.</value>
        /// <example>VEHICLE-123</example>
        [DataMember(Name = "vehicleId", IsRequired = true, EmitDefaultValue = true)]
        public string VehicleId { get; set; }

        /// <summary>
        /// The unique identifiers of the resources assigned to the vehicle executing the route.
        /// </summary>
        /// <value>The unique identifiers of the resources assigned to the vehicle executing the route.</value>
        [DataMember(Name = "resourceIds", EmitDefaultValue = false)]
        public List<string> ResourceIds { get; set; }

        /// <summary>
        /// The point in time when the route should start. The start time will be respected as closely as possible. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). The date must not be before &#x60;1970-01-01T00:00:00+00:00&#x60; nor after &#x60;2037-12-31T23:59:59+00:00&#x60;. The date must provide an offset to UTC.
        /// </summary>
        /// <value>The point in time when the route should start. The start time will be respected as closely as possible. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). The date must not be before &#x60;1970-01-01T00:00:00+00:00&#x60; nor after &#x60;2037-12-31T23:59:59+00:00&#x60;. The date must provide an offset to UTC.</value>
        /// <example>2023-10-03T12:00Z</example>
        [DataMember(Name = "start", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset? Start { get; set; }

        /// <summary>
        /// The unique identifier of the location where the route starts. This must either be the provided start location of the vehicle, the location of the first stop when the vehicle has no fixed start location or a layover location. When omitted, the location will be automatically inferred, assuming a layover does not occur before this route.
        /// </summary>
        /// <value>The unique identifier of the location where the route starts. This must either be the provided start location of the vehicle, the location of the first stop when the vehicle has no fixed start location or a layover location. When omitted, the location will be automatically inferred, assuming a layover does not occur before this route.</value>
        /// <example>GHENT</example>
        [DataMember(Name = "startLocationId", EmitDefaultValue = true)]
        public string StartLocationId { get; set; }

        /// <summary>
        /// The unique identifier of the location where the route ends. This must either be the provided end location of the vehicle, the location of the last stop when the vehicle has no fixed end location or a layover location. When omitted, the location will be automatically inferred, assuming a layover does not occur after this route.
        /// </summary>
        /// <value>The unique identifier of the location where the route ends. This must either be the provided end location of the vehicle, the location of the last stop when the vehicle has no fixed end location or a layover location. When omitted, the location will be automatically inferred, assuming a layover does not occur after this route.</value>
        /// <example>BRUSSELS</example>
        [DataMember(Name = "endLocationId", EmitDefaultValue = true)]
        public string EndLocationId { get; set; }

        /// <summary>
        /// A sequence of tasks scheduled on the route.
        /// </summary>
        /// <value>A sequence of tasks scheduled on the route.</value>
        [DataMember(Name = "tasks", EmitDefaultValue = false)]
        public List<RouteOptimizationTaskStructure> Tasks { get; set; }

        /// <summary>
        /// A list of breaks scheduled on the route. When omitted, reconstruction will make a best effort to schedule breaks in order to satisfy the break settings.
        /// </summary>
        /// <value>A list of breaks scheduled on the route. When omitted, reconstruction will make a best effort to schedule breaks in order to satisfy the break settings.</value>
        [DataMember(Name = "breaks", EmitDefaultValue = false)]
        public List<RouteOptimizationBreakStructure> Breaks { get; set; }

        /// <summary>
        /// A list of charging times scheduled on the route. When omitted, reconstruction will make a best effort to schedule charging in order to satisfy the vehicle’s requirements.
        /// </summary>
        /// <value>A list of charging times scheduled on the route. When omitted, reconstruction will make a best effort to schedule charging in order to satisfy the vehicle’s requirements.</value>
        [DataMember(Name = "charging", EmitDefaultValue = false)]
        public List<RouteOptimizationChargingStructure> Charging { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RouteOptimizationRouteStructure {\n");
            sb.Append("  VehicleId: ").Append(VehicleId).Append("\n");
            sb.Append("  ResourceIds: ").Append(ResourceIds).Append("\n");
            sb.Append("  Start: ").Append(Start).Append("\n");
            sb.Append("  StartLocationId: ").Append(StartLocationId).Append("\n");
            sb.Append("  EndLocationId: ").Append(EndLocationId).Append("\n");
            sb.Append("  Tasks: ").Append(Tasks).Append("\n");
            sb.Append("  Breaks: ").Append(Breaks).Append("\n");
            sb.Append("  Charging: ").Append(Charging).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // VehicleId (string) maxLength
            if (this.VehicleId != null && this.VehicleId.Length > 36)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VehicleId, length must be less than 36.", new [] { "VehicleId" });
            }

            // VehicleId (string) minLength
            if (this.VehicleId != null && this.VehicleId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VehicleId, length must be greater than 1.", new [] { "VehicleId" });
            }

            if (this.VehicleId != null) {
                // VehicleId (string) pattern
                Regex regexVehicleId = new Regex(@"^[a-zA-Z0-9_-]{1,36}$", RegexOptions.CultureInvariant);
                if (!regexVehicleId.Match(this.VehicleId).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VehicleId, must match a pattern of " + regexVehicleId, new [] { "VehicleId" });
                }
            }

            // StartLocationId (string) maxLength
            if (this.StartLocationId != null && this.StartLocationId.Length > 36)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartLocationId, length must be less than 36.", new [] { "StartLocationId" });
            }

            // StartLocationId (string) minLength
            if (this.StartLocationId != null && this.StartLocationId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartLocationId, length must be greater than 1.", new [] { "StartLocationId" });
            }

            if (this.StartLocationId != null) {
                // StartLocationId (string) pattern
                Regex regexStartLocationId = new Regex(@"^[a-zA-Z0-9_-]{1,36}$", RegexOptions.CultureInvariant);
                if (!regexStartLocationId.Match(this.StartLocationId).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartLocationId, must match a pattern of " + regexStartLocationId, new [] { "StartLocationId" });
                }
            }

            // EndLocationId (string) maxLength
            if (this.EndLocationId != null && this.EndLocationId.Length > 36)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EndLocationId, length must be less than 36.", new [] { "EndLocationId" });
            }

            // EndLocationId (string) minLength
            if (this.EndLocationId != null && this.EndLocationId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EndLocationId, length must be greater than 1.", new [] { "EndLocationId" });
            }

            if (this.EndLocationId != null) {
                // EndLocationId (string) pattern
                Regex regexEndLocationId = new Regex(@"^[a-zA-Z0-9_-]{1,36}$", RegexOptions.CultureInvariant);
                if (!regexEndLocationId.Match(this.EndLocationId).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EndLocationId, must match a pattern of " + regexEndLocationId, new [] { "EndLocationId" });
                }
            }

            yield break;
        }
    }

}
