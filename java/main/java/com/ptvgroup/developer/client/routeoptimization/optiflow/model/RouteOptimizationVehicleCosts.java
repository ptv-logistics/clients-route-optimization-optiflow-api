/*
 * Route Optimization OptiFlow
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.routeoptimization.optiflow.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.routeoptimization.optiflow.model.RouteOptimizationOverdistanceCost;
import com.ptvgroup.developer.client.routeoptimization.optiflow.model.RouteOptimizationOverstopCost;
import com.ptvgroup.developer.client.routeoptimization.optiflow.model.RouteOptimizationOvertimeCost;
import com.ptvgroup.developer.client.routeoptimization.optiflow.model.RouteOptimizationRepositioningEffortCost;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * Defines the costs for using the vehicle to execute tasks.
 */
@JsonPropertyOrder({
  RouteOptimizationVehicleCosts.JSON_PROPERTY_PER_HOUR,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_PER_KILOMETER,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_PER_STOP,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_FIXED,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_OVERTIMES,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_OVERDISTANCES,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_OVERSTOPS,
  RouteOptimizationVehicleCosts.JSON_PROPERTY_REPOSITIONING_EFFORTS
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-06-03T08:03:45.906081716Z[Etc/UTC]", comments = "Generator version: 7.5.0")
public class RouteOptimizationVehicleCosts {
  public static final String JSON_PROPERTY_PER_HOUR = "perHour";
  private Double perHour;

  public static final String JSON_PROPERTY_PER_KILOMETER = "perKilometer";
  private Double perKilometer;

  public static final String JSON_PROPERTY_PER_STOP = "perStop";
  private Double perStop;

  public static final String JSON_PROPERTY_FIXED = "fixed";
  private Double fixed = 0d;

  public static final String JSON_PROPERTY_OVERTIMES = "overtimes";
  private List<RouteOptimizationOvertimeCost> overtimes = new ArrayList<>();

  public static final String JSON_PROPERTY_OVERDISTANCES = "overdistances";
  private List<RouteOptimizationOverdistanceCost> overdistances = new ArrayList<>();

  public static final String JSON_PROPERTY_OVERSTOPS = "overstops";
  private List<RouteOptimizationOverstopCost> overstops = new ArrayList<>();

  public static final String JSON_PROPERTY_REPOSITIONING_EFFORTS = "repositioningEfforts";
  private List<RouteOptimizationRepositioningEffortCost> repositioningEfforts = new ArrayList<>();

  public RouteOptimizationVehicleCosts() { 
  }

  public RouteOptimizationVehicleCosts perHour(Double perHour) {
    this.perHour = perHour;
    return this;
  }

   /**
   * Specifies the cost for every hour the vehicle is used.
   * minimum: 0
   * @return perHour
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_PER_HOUR)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Double getPerHour() {
    return perHour;
  }


  @JsonProperty(JSON_PROPERTY_PER_HOUR)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPerHour(Double perHour) {
    this.perHour = perHour;
  }


  public RouteOptimizationVehicleCosts perKilometer(Double perKilometer) {
    this.perKilometer = perKilometer;
    return this;
  }

   /**
   * Specifies the cost for every kilometer driven with the vehicle.
   * minimum: 0
   * @return perKilometer
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_PER_KILOMETER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Double getPerKilometer() {
    return perKilometer;
  }


  @JsonProperty(JSON_PROPERTY_PER_KILOMETER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPerKilometer(Double perKilometer) {
    this.perKilometer = perKilometer;
  }


  public RouteOptimizationVehicleCosts perStop(Double perStop) {
    this.perStop = perStop;
    return this;
  }

   /**
   * Specifies the cost for every stop on the route of the vehicle.
   * minimum: 0
   * @return perStop
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PER_STOP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Double getPerStop() {
    return perStop;
  }


  @JsonProperty(JSON_PROPERTY_PER_STOP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPerStop(Double perStop) {
    this.perStop = perStop;
  }


  public RouteOptimizationVehicleCosts fixed(Double fixed) {
    this.fixed = fixed;
    return this;
  }

   /**
   * Specifies the fixed cost for assigning a route to the vehicle.
   * minimum: 0
   * @return fixed
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FIXED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Double getFixed() {
    return fixed;
  }


  @JsonProperty(JSON_PROPERTY_FIXED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFixed(Double fixed) {
    this.fixed = fixed;
  }


  public RouteOptimizationVehicleCosts overtimes(List<RouteOptimizationOvertimeCost> overtimes) {
    this.overtimes = overtimes;
    return this;
  }

  public RouteOptimizationVehicleCosts addOvertimesItem(RouteOptimizationOvertimeCost overtimesItem) {
    if (this.overtimes == null) {
      this.overtimes = new ArrayList<>();
    }
    this.overtimes.add(overtimesItem);
    return this;
  }

   /**
   * A list of overtime costs that describe an increasing cost if the route duration exceeds a threshold. For each exceeded threshold, the additional cost for the extra hours contributes to the total cost of the route.
   * @return overtimes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_OVERTIMES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<RouteOptimizationOvertimeCost> getOvertimes() {
    return overtimes;
  }


  @JsonProperty(JSON_PROPERTY_OVERTIMES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOvertimes(List<RouteOptimizationOvertimeCost> overtimes) {
    this.overtimes = overtimes;
  }


  public RouteOptimizationVehicleCosts overdistances(List<RouteOptimizationOverdistanceCost> overdistances) {
    this.overdistances = overdistances;
    return this;
  }

  public RouteOptimizationVehicleCosts addOverdistancesItem(RouteOptimizationOverdistanceCost overdistancesItem) {
    if (this.overdistances == null) {
      this.overdistances = new ArrayList<>();
    }
    this.overdistances.add(overdistancesItem);
    return this;
  }

   /**
   * A list of overdistance costs that describe an increasing cost if the total distance of a route exceeds a threshold. For each exceeded threshold, the additional cost for the extra kilometers contributes to the total cost of the route.
   * @return overdistances
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_OVERDISTANCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<RouteOptimizationOverdistanceCost> getOverdistances() {
    return overdistances;
  }


  @JsonProperty(JSON_PROPERTY_OVERDISTANCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOverdistances(List<RouteOptimizationOverdistanceCost> overdistances) {
    this.overdistances = overdistances;
  }


  public RouteOptimizationVehicleCosts overstops(List<RouteOptimizationOverstopCost> overstops) {
    this.overstops = overstops;
    return this;
  }

  public RouteOptimizationVehicleCosts addOverstopsItem(RouteOptimizationOverstopCost overstopsItem) {
    if (this.overstops == null) {
      this.overstops = new ArrayList<>();
    }
    this.overstops.add(overstopsItem);
    return this;
  }

   /**
   * A list of overstop costs that describe an increasing cost if the number of stops of a route exceeds a threshold. For each exceeded threshold, the additional cost for the extra stops contributes to the total cost of the route.
   * @return overstops
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_OVERSTOPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<RouteOptimizationOverstopCost> getOverstops() {
    return overstops;
  }


  @JsonProperty(JSON_PROPERTY_OVERSTOPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOverstops(List<RouteOptimizationOverstopCost> overstops) {
    this.overstops = overstops;
  }


  public RouteOptimizationVehicleCosts repositioningEfforts(List<RouteOptimizationRepositioningEffortCost> repositioningEfforts) {
    this.repositioningEfforts = repositioningEfforts;
    return this;
  }

  public RouteOptimizationVehicleCosts addRepositioningEffortsItem(RouteOptimizationRepositioningEffortCost repositioningEffortsItem) {
    if (this.repositioningEfforts == null) {
      this.repositioningEfforts = new ArrayList<>();
    }
    this.repositioningEfforts.add(repositioningEffortsItem);
    return this;
  }

   /**
   * Specifies a list of repositioning effort costs that describe an increasing cost if the route&#39;s repositioning effort exceeds a threshold.  When two orders are loaded into the same compartment and delivered in the same order, we refer to them as a non-last-in-first-out (non-LIFO) pair. Any non-LIFO pair of orders requires repositioning in the vehicle, as the last picked-up order obstructs the first order that needs to be delivered. The effort involved in this repositioning is the minimum effort required for the two orders. The total repositioning effort for the route is the sum of the repositioning efforts for all non-LIFO pairs of orders.
   * @return repositioningEfforts
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REPOSITIONING_EFFORTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<RouteOptimizationRepositioningEffortCost> getRepositioningEfforts() {
    return repositioningEfforts;
  }


  @JsonProperty(JSON_PROPERTY_REPOSITIONING_EFFORTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRepositioningEfforts(List<RouteOptimizationRepositioningEffortCost> repositioningEfforts) {
    this.repositioningEfforts = repositioningEfforts;
  }


  /**
   * Return true if this VehicleCosts object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RouteOptimizationVehicleCosts vehicleCosts = (RouteOptimizationVehicleCosts) o;
    return Objects.equals(this.perHour, vehicleCosts.perHour) &&
        Objects.equals(this.perKilometer, vehicleCosts.perKilometer) &&
        Objects.equals(this.perStop, vehicleCosts.perStop) &&
        Objects.equals(this.fixed, vehicleCosts.fixed) &&
        Objects.equals(this.overtimes, vehicleCosts.overtimes) &&
        Objects.equals(this.overdistances, vehicleCosts.overdistances) &&
        Objects.equals(this.overstops, vehicleCosts.overstops) &&
        Objects.equals(this.repositioningEfforts, vehicleCosts.repositioningEfforts);
  }

  @Override
  public int hashCode() {
    return Objects.hash(perHour, perKilometer, perStop, fixed, overtimes, overdistances, overstops, repositioningEfforts);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RouteOptimizationVehicleCosts {\n");
    sb.append("    perHour: ").append(toIndentedString(perHour)).append("\n");
    sb.append("    perKilometer: ").append(toIndentedString(perKilometer)).append("\n");
    sb.append("    perStop: ").append(toIndentedString(perStop)).append("\n");
    sb.append("    fixed: ").append(toIndentedString(fixed)).append("\n");
    sb.append("    overtimes: ").append(toIndentedString(overtimes)).append("\n");
    sb.append("    overdistances: ").append(toIndentedString(overdistances)).append("\n");
    sb.append("    overstops: ").append(toIndentedString(overstops)).append("\n");
    sb.append("    repositioningEfforts: ").append(toIndentedString(repositioningEfforts)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `perHour` to the URL query string
    if (getPerHour() != null) {
      joiner.add(String.format("%sperHour%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPerHour()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `perKilometer` to the URL query string
    if (getPerKilometer() != null) {
      joiner.add(String.format("%sperKilometer%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPerKilometer()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `perStop` to the URL query string
    if (getPerStop() != null) {
      joiner.add(String.format("%sperStop%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPerStop()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `fixed` to the URL query string
    if (getFixed() != null) {
      joiner.add(String.format("%sfixed%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getFixed()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `overtimes` to the URL query string
    if (getOvertimes() != null) {
      for (int i = 0; i < getOvertimes().size(); i++) {
        if (getOvertimes().get(i) != null) {
          joiner.add(getOvertimes().get(i).toUrlQueryString(String.format("%sovertimes%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `overdistances` to the URL query string
    if (getOverdistances() != null) {
      for (int i = 0; i < getOverdistances().size(); i++) {
        if (getOverdistances().get(i) != null) {
          joiner.add(getOverdistances().get(i).toUrlQueryString(String.format("%soverdistances%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `overstops` to the URL query string
    if (getOverstops() != null) {
      for (int i = 0; i < getOverstops().size(); i++) {
        if (getOverstops().get(i) != null) {
          joiner.add(getOverstops().get(i).toUrlQueryString(String.format("%soverstops%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `repositioningEfforts` to the URL query string
    if (getRepositioningEfforts() != null) {
      for (int i = 0; i < getRepositioningEfforts().size(); i++) {
        if (getRepositioningEfforts().get(i) != null) {
          joiner.add(getRepositioningEfforts().get(i).toUrlQueryString(String.format("%srepositioningEfforts%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    return joiner.toString();
  }
}

